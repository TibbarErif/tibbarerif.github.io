<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="名为怪物的游戏——《星之魔女》FC小游戏移植（七）"><meta name="keywords" content="unity,开发技术"><meta name="author" content="火烧兔子"><meta name="copyright" content="火烧兔子"><title>名为怪物的游戏——《星之魔女》FC小游戏移植（七） | 火兔游戏工作室</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%A9%E5%AE%B6%E5%8F%97%E4%BC%A4"><span class="toc-number">2.</span> <span class="toc-text">玩家受伤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E4%BC%A4-%E6%AD%BB%E4%BA%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">2.2.</span> <span class="toc-text">受伤&#x2F;死亡动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E7%A6%BB%E5%8F%97%E4%BC%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">抽离受伤事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E5%88%B0%E6%95%8C%E4%BA%BA"><span class="toc-number">2.4.</span> <span class="toc-text">碰到敌人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E4%BC%A4%E5%8A%A8%E7%94%BB%E4%B8%8D%E8%A7%A3%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">受伤动画不解除问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%95%8C%E6%97%B6%E9%97%B4"><span class="toc-number">2.6.</span> <span class="toc-text">无敌时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BB%E9%80%80%E6%95%88%E6%9E%9C"><span class="toc-number">2.7.</span> <span class="toc-text">击退效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%B7%91%E5%8A%A8%E7%94%BB%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">小跑动画问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">动画不一致问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E4%BC%A4%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E9%99%90%E5%88%B6"><span class="toc-number">2.10.</span> <span class="toc-text">受伤下的操作限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AFUI"><span class="toc-number">3.</span> <span class="toc-text">场景UI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">场景控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%B0%E6%98%BE%E7%A4%BA"><span class="toc-number">3.2.</span> <span class="toc-text">分数显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%80%BC%E6%98%BE%E7%A4%BA"><span class="toc-number">3.3.</span> <span class="toc-text">生命值显示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout"><span class="toc-number">3.3.1.</span> <span class="toc-text">Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E5%BD%A2%E8%A1%80%E9%87%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">心形血量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%80%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.3.</span> <span class="toc-text">血量控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%93%E5%85%B7%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">道具系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%93%E5%85%B7%E5%9F%BA%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">道具基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%88%86%E9%81%93%E5%85%B7"><span class="toc-number">4.2.</span> <span class="toc-text">加分道具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C"><span class="toc-number">4.2.1.</span> <span class="toc-text">动态效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%B1%E6%A1%83"><span class="toc-number">4.2.2.</span> <span class="toc-text">樱桃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E5%B8%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">金币</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%80%BC%E6%98%BE%E7%A4%BA"><span class="toc-number">4.2.4.</span> <span class="toc-text">分值显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%A1%80%E9%81%93%E5%85%B7"><span class="toc-number">4.3.</span> <span class="toc-text">加血道具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%A8%80"><span class="toc-number">5.</span> <span class="toc-text">后言</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/05/02/JjR7MmfePax3oc2.jpg"></div><div class="author-info__name text-center">火烧兔子</div><div class="author-info__description text-center">我的世界，在你手中。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">火兔游戏工作室</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">名为怪物的游戏——《星之魔女》FC小游戏移植（七）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8D%E4%B8%BA%E6%80%AA%E7%89%A9%E7%9A%84%E6%B8%B8%E6%88%8F/">名为怪物的游戏</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8D%E4%B8%BA%E6%80%AA%E7%89%A9%E7%9A%84%E6%B8%B8%E6%88%8F/%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/">制作过程</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇完成角色系统和道具系统。</p>
<p>小游戏的制作也接近尾声了。</p>
<h2 id="玩家受伤"><a href="#玩家受伤" class="headerlink" title="玩家受伤"></a>玩家受伤</h2><p>主角受到的伤害来自两种，第一是被敌人发射的子弹击中，第二是碰到敌人。</p>
<p>而敌人受伤只来源于玩家的攻击，主角碰到敌人只有主角会受到伤害，敌人不会受伤。</p>
<p>给子弹加上 Bullet 的 Tag（标签），给敌人加上 Enemy 标签。</p>
<p>之后就可以在碰撞回调中通过标签区分碰撞对象。</p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>首先需要知道碰到玩家的物体是什么，可以用上面说的标签来区分。</p>
<p>如果是碰到道具则应该获得加分或加血，如果是敌人和子弹才会受到伤害。</p>
<p>编辑 <code>MiniGame_Player</code> 脚本，添加碰撞监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    string tag &#x3D; collision.gameObject.tag;</span><br><span class="line"></span><br><span class="line">    switch (tag)</span><br><span class="line">    &#123;</span><br><span class="line">        case &quot;Enemy&quot;:</span><br><span class="line">            TouchEnemy(collision);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Item&quot;:</span><br><span class="line">            TouchItem(collision);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Bullet&quot;:</span><br><span class="line">            TouchBullet(collision);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void TouchEnemy(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void TouchItem(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void TouchBullet(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的碰撞事件是两个刚体之间的碰撞，因此需要使用 <code>OnCollisionEnter2D</code> 监听。</p>
<p>其实这里有两种设计方案，①在角色身上监听碰撞事件 ②在道具上监听碰撞事件</p>
<p>一般来说在“被动”的一方身上绑定监听事件比较符合常规思想。</p>
<p>比如道具“被”主角吃，那么就在道具上处理吃到道具的效果；</p>
<p>再比如主角“被”敌人的子弹击中，那么就在主角身上处理受伤事件。</p>
<p>所以这里的 <code>TouchItem</code> 有点多余，以后可能会移除。</p>
<p>此处设置角色与 3 种类型的物体发生碰撞的处理，即敌人、道具、子弹。</p>
<p>具体的方法留空，接下来逐一进行实现。</p>
<h3 id="受伤-死亡动画"><a href="#受伤-死亡动画" class="headerlink" title="受伤/死亡动画"></a>受伤/死亡动画</h3><p>增加受伤和死亡动画的状态机。</p>
<p>任意状态都可以直接进入受伤状态，而当受伤判定为死亡时，进入死亡动画。</p>
<p><img src="https://files.catbox.moe/6xpk7k.jpg" alt="主角的受伤和死亡状态"></p>
<h3 id="抽离受伤事件"><a href="#抽离受伤事件" class="headerlink" title="抽离受伤事件"></a>抽离受伤事件</h3><p>因为角色受到伤害会进入一个保护状态，要与敌人区分开来。</p>
<p>因此需要修改之前写的游戏角色基类，将 <code>TakeDamage</code> 方法改成抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void TakeDamage(float damage);</span><br></pre></td></tr></table></figure>

<p>接着在 <code>MiniGame_Player</code> 方法里实现受伤处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public override void TakeDamage(float damage)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;受到伤害：&quot; + damage);</span><br><span class="line"></span><br><span class="line">    animator.SetBool(&quot;hurt&quot;, true);</span><br><span class="line">    currentHP -&#x3D; damage;</span><br><span class="line"></span><br><span class="line">    Wait(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(&quot;hurt&quot;, false);</span><br><span class="line"></span><br><span class="line">        if (currentHP &lt;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            DeadCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, 0.25f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="碰到敌人"><a href="#碰到敌人" class="headerlink" title="碰到敌人"></a>碰到敌人</h3><p>玩家碰到敌人时，显示受伤动画，减少血量，进入场景测试。</p>
<p><img src="https://files.catbox.moe/3i5m3g.gif" alt="撞到敌人测试"></p>
<p>发现撞到敌人之后，虽然播放了受伤动画，但是却没有在 0.25s 后解除。</p>
<p>这是因为受伤动画没有转换成其他动画的设置。</p>
<h3 id="受伤动画不解除问题"><a href="#受伤动画不解除问题" class="headerlink" title="受伤动画不解除问题"></a>受伤动画不解除问题</h3><p>修改动画状态机，当解除受伤动画时，让主角变成待机状态。</p>
<p><img src="https://files.catbox.moe/0q2ogj.jpg" alt="受伤动画转换为待机动画"></p>
<p>然后再进入游戏测试：</p>
<p><img src="https://files.catbox.moe/8856n6.gif" alt="受伤修改后测试"></p>
<p>受伤动画不解除的问题解决了，但是可以发现，如果继续停留在原地，角色与敌人依然保持接触状态，却不会再触发受伤事件了。这是因为两个刚体组件发生碰撞时，会出现弹开的情况。</p>
<h3 id="无敌时间"><a href="#无敌时间" class="headerlink" title="无敌时间"></a>无敌时间</h3><p>当主角受伤的时候会进入短暂的无敌，避免玩家连续碰到敌人还没反应过来就直接 gg 了。</p>
<p>增加一个变量用来设定角色无敌状态的持续时间，另一个变量保存当前无敌剩余时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public float pretectedTime &#x3D; 1f;</span><br><span class="line">private float currentPretectedTime;</span><br></pre></td></tr></table></figure>

<p>当玩家受伤时，就赋予无敌时间，持续时间在 Update 方法里减少。</p>
<p>修改受伤事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void TouchEnemy(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (currentPretectedTime &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentPretectedTime &#x3D; pretectedTime;</span><br><span class="line"></span><br><span class="line">    TakeDamage(1f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在无敌时间里，再次调用受伤方法就直接返回，否则计算伤害同时赋予玩家无敌时间。</p>
<p>接着消除无敌时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void FixedUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    ProtectedTime();</span><br><span class="line">    Shoot();</span><br><span class="line">    Move();</span><br><span class="line">    Jump();</span><br><span class="line">    GroundCheck();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ProtectedTime()</span><br><span class="line">&#123;</span><br><span class="line">    if (currentPretectedTime &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        currentPretectedTime -&#x3D; Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>FixedUpdate</code> 方法里计算无敌时间。</p>
<p>最后进入游戏场景测试：</p>
<p><img src="https://files.catbox.moe/oa3v53.gif" alt="无敌时间测试"></p>
<p>主角跟敌人碰撞之后，还是“停在原地”，看起来依然与敌人保持着接触。</p>
<p>实际上，无敌时间确实生效了，但是玩家跟敌人保持接触却没有受到伤害不是因为无敌时间的关系。</p>
<p>而是玩家在撞到怪物身上的时候，发生“弹开”的情况。</p>
<p>只要稍微修改一下碰撞盒子就可以看出效果了：</p>
<p><img src="https://files.catbox.moe/q4qmhr.gif" alt="碰撞盒子修改测试"></p>
<p>把敌人的碰撞盒子变大的时候，可以看到主角被“击退”了一步。</p>
<p>但是这个弹力实际上很小，所以肉眼看不出来。</p>
<h3 id="击退效果"><a href="#击退效果" class="headerlink" title="击退效果"></a>击退效果</h3><p>修改弹力需要创建一个物理材质：</p>
<p><img src="https://files.catbox.moe/p9ud5b.jpg" alt="弹性材质"></p>
<p>然后把材质拖到敌人的碰撞盒子上。</p>
<p>为了测试弹力效果，先将弹力设置成一个比较大的值：10.</p>
<p>观察效果：</p>
<p><img src="https://files.catbox.moe/roegwf.gif" alt="增强弹力效果"></p>
<p>可以观察到角色撞到敌人之后被弹开了一段较大的距离。</p>
<p>如果仔细观察的话，还能发现角色又会向前挪动，继续与敌人发生碰撞，然后反复碰撞出现“抖动”的情况。</p>
<p>原因是角色受伤状态下仍然可以按方向键向前移动，所以又与前方的敌人发生了碰撞。除此之外，由于移动是用 <code>GetAxis</code> 来监听的，即使松开按键也存在一个缓冲的过程，速度并不会直接降低为 0，所以还会保持向前移动一小段距离，又与敌人产生碰撞。</p>
<p>只要修改移动方法，在无敌时间里禁止角色受到水平方向的力推动玩家就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> private void Move()</span><br><span class="line">&#123;</span><br><span class="line">    if (currentPretectedTime &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    animator.SetFloat(&quot;horizontal&quot;, Mathf.Abs(horizontal));</span><br><span class="line"></span><br><span class="line">    rb.velocity &#x3D; new Vector2(horizontal * moveSpeed, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">    if (horizontal &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(1, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (horizontal &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(-1, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试效果：</p>
<p><img src="https://files.catbox.moe/e1zyfr.gif" alt="修改之后的弹力效果"></p>
<p>因为弹力太大所以主角撞到敌人之后直接飞出屏幕外面了~</p>
<p>把弹力跳到 0.25 重新测试：</p>
<p><img src="https://files.catbox.moe/n1x4sd.gif" alt="降低弹力的效果"></p>
<p>可以看到这样好多了，但是主角在受伤之后会进入“小跑动画”。</p>
<h3 id="小跑动画问题"><a href="#小跑动画问题" class="headerlink" title="小跑动画问题"></a>小跑动画问题</h3><p>这是因为玩家在受伤的时候仍然可以按住水平方向键，因此还会播放奔跑动画。</p>
<p>在控制角色移动的方法中，修改动画参数就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void Move()</span><br><span class="line">&#123;</span><br><span class="line">    if (currentPretectedTime &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置水平参数为0，即不会再播放奔跑动画了</span><br><span class="line">        animator.SetFloat(&quot;horizontal&quot;, 0);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    animator.SetFloat(&quot;horizontal&quot;, Mathf.Abs(horizontal));</span><br><span class="line"></span><br><span class="line">    rb.velocity &#x3D; new Vector2(horizontal * moveSpeed, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">    if (horizontal &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(1, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (horizontal &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(-1, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还需要注意一个问题，这里因为用了 <code>currentPretectedTime</code> 来作为判定时间，就必须让受伤动画的“硬直”时间与无敌时间相同，否则无敌状态还没解除，受伤动画就先解除了，角色就会变成待机状态。</p>
<p><img src="https://files.catbox.moe/kydjby.gif" alt="受伤动画时间不一致问题"></p>
<h3 id="动画不一致问题"><a href="#动画不一致问题" class="headerlink" title="动画不一致问题"></a>动画不一致问题</h3><p>修改受伤动画解除事件与无敌时间保持一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public override void TakeDamage(float damage)</span><br><span class="line">&#123;</span><br><span class="line">    animator.SetBool(&quot;hurt&quot;, true);</span><br><span class="line">    currentHP -&#x3D; damage;</span><br><span class="line"></span><br><span class="line">    Wait(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(&quot;hurt&quot;, false);</span><br><span class="line"></span><br><span class="line">        if (currentHP &lt;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            DeadCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, pretectedTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Wait</code> 方法的第二个参数改成无敌时间即可，然后继续测试：</p>
<p><img src="https://files.catbox.moe/nogqt4.gif" alt="受伤动画优化效果"></p>
<h3 id="受伤下的操作限制"><a href="#受伤下的操作限制" class="headerlink" title="受伤下的操作限制"></a>受伤下的操作限制</h3><p>但是又有新的问题，受伤的时候还可以跳跃和发射子弹。</p>
<p><img src="https://files.catbox.moe/cu01km.gif" alt="受伤跳跃和攻击"></p>
<p>受伤跳跃还可以接受，但是受伤了还能发射子弹就有点离谱。</p>
<p>修改 <code>Shoot</code> 方法，当角色在无敌状态时，不能发射子弹攻击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void Shoot()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 加上无敌时间判断</span><br><span class="line">    if (currentPretectedTime &lt; 0 &amp;&amp; isShoot)</span><br><span class="line">    &#123;</span><br><span class="line">        isShoot &#x3D; false;</span><br><span class="line">        animator.SetBool(&quot;shoot&quot;, true);</span><br><span class="line"></span><br><span class="line">        GameObject prefab &#x3D; Resources.Load(&quot;Prefabs&#x2F;MiniGame&#x2F;StarBullet&quot;) as GameObject;</span><br><span class="line">        GameObject bulletObj &#x3D; Instantiate(prefab, firePoint);</span><br><span class="line"></span><br><span class="line">        MiniGame_Bullet bullet &#x3D; bulletObj.GetComponent&lt;MiniGame_Bullet&gt;();</span><br><span class="line">        bullet.attacker &#x3D; this;</span><br><span class="line"></span><br><span class="line">        bulletObj.transform.SetParent(bg);</span><br><span class="line"></span><br><span class="line">        Wait(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(&quot;shoot&quot;, false);</span><br><span class="line">        &#125;, 0.05f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示效果：</p>
<p><img src="https://files.catbox.moe/bb6thw.gif" alt="受伤时限制攻击"></p>
<p>玩家受伤动作总算完成了（撒花）</p>
<h2 id="场景UI"><a href="#场景UI" class="headerlink" title="场景UI"></a>场景UI</h2><p>角色受伤虽然减少了 HP，但是现在玩家还看不到具体的生命值还有多少。</p>
<p>这时候就要开始制作场景的 UI（界面）。</p>
<p>包括：</p>
<ul>
<li>显示剩余生命值</li>
<li>显示当前得分</li>
</ul>
<p>场景 UI 图例：</p>
<p><img src="https://files.catbox.moe/emgazc.jpg" alt="场景UI"></p>
<p>左上角显示生命值，右上角显示得分。</p>
<h3 id="场景控制"><a href="#场景控制" class="headerlink" title="场景控制"></a>场景控制</h3><p>需要一个脚本用来控制整个小游戏的流程。</p>
<p>如进入游戏、游戏结束、UI 显示。</p>
<p>新建脚本 <code>MiniGame_Controller</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class MiniGame_Controller : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Text scoreText;</span><br><span class="line"></span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        this.AddScore(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void AddScore(int score)</span><br><span class="line">    &#123;</span><br><span class="line">        this.score +&#x3D; score;</span><br><span class="line">        scoreText.text &#x3D; this.score.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本现在包含了得分显示的方法。</p>
<p><code>AddScore</code> 方法传入一个分数参数，更新场景中的文本显示数字。</p>
<p>在游戏对象启动的时候，调用了 <code>this.AddScore(0)</code> 来更新文本。</p>
<p>脚本挂在小游戏根节点。</p>
<p><img src="https://files.catbox.moe/7po71z.jpg" alt="控制器脚本"></p>
<p>小游戏节点的标签更改为：<code>Controller</code></p>
<p>这样在别的对象中可以直接通过标签来获得场景控制器。</p>
<h3 id="分数显示"><a href="#分数显示" class="headerlink" title="分数显示"></a>分数显示</h3><p>创建一个 Text 组件，放在右上角的位置即可。</p>
<p><img src="https://files.catbox.moe/jq4hpc.jpg" alt="分数显示"></p>
<p>将文本节点拖到控制器的参数上面。</p>
<p>进入游戏场景测试：</p>
<p><img src="https://files.catbox.moe/nb28l6.gif" alt="测试分数文本"></p>
<p>“得分”两字在进入游戏的时候会自动更新为实际的分数值。</p>
<h3 id="生命值显示"><a href="#生命值显示" class="headerlink" title="生命值显示"></a>生命值显示</h3><p>生命值在界面左上角显示。</p>
<p><img src="https://files.catbox.moe/zbms1u.jpg" alt="生命值UI结构示意图"></p>
<p>UI 是由特殊的自动排列 Layout 结构，实现心形血量的自动对齐。</p>
<p>所以这里需要分成两块制作：① 放置心形血量的 Layout ② 心形血量（单体）</p>
<p>还有一种做法就是直接“写死”，即固定角色的血量上限是 5 颗心。</p>
<p>这样不用自动排列结构也不需要单独抽离出单体的心形血量。</p>
<p>好处是更简单，坏处是不利于扩展，这里就不偷懒了，不然以后还得回头修改。</p>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>创建一个空的对象，然后需要注意的是，这里的 Transfrom 并不是普通的，而是 UI 用的 <code>Rect Transfrom</code>。</p>
<p>普通的 Transform 示例：</p>
<p><img src="https://files.catbox.moe/r1w7pd.jpg" alt="普通的transform"></p>
<p>UI 用的 Rect Transfrom：</p>
<p><img src="https://files.catbox.moe/rl8131.jpg" alt="UI用的rect transform"></p>
<p>可以看到 UI 的对象有宽度和高度，而且还有锚域（不是锚点）。</p>
<p>这个真的是非常难理解的一个要点，刚开始学的时候，卡了一个下午都弄不清楚。</p>
<p>有一篇写的非常好的文章：<a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/16570">Unity进阶技巧 - RectTransform详解</a></p>
<p>其实现在我也还没完全搞懂这个锚域的原理……所幸还不需要用到。</p>
<p>Layout 需要设置一个宽度，相当于是一个容器，用来盛放心形图片（血量）。</p>
<p>给 Layout 添加 <code>Grid Layout Group</code> 组件：</p>
<p><img src="https://files.catbox.moe/aqlvth.jpg" alt="容器组件"></p>
<p>这个组件可以设置单元格的大小，然后按照指定的规则进行自动排列。</p>
<p>设置好之后，把心形图片拖到 Layout 底下，当做子节点，然后测试效果：</p>
<p><img src="https://files.catbox.moe/gb1nrx.gif" alt="测试容器效果"></p>
<p>可以看到每次创建一个新的心形图片的时候，容器自动将其排列，超过容器的宽度时自动换行。</p>
<p>容器这样就设置好了。</p>
<h4 id="心形血量"><a href="#心形血量" class="headerlink" title="心形血量"></a>心形血量</h4><p>心形血量包括两种形态：①充满血量 ②空</p>
<p>创建脚本 <code>MiniGame_Heart</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class MiniGame_Heart : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Sprite[] sprites;</span><br><span class="line"></span><br><span class="line">    private Image icon;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        icon &#x3D; GetComponent&lt;Image&gt;();</span><br><span class="line"></span><br><span class="line">        SetActive(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetActive(bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (result &#x3D;&#x3D; true)</span><br><span class="line">        &#123;</span><br><span class="line">            index &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        icon.sprite &#x3D; sprites[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Sprite[] sprites</code> 是一个精灵数组（即图片），把空的心和填满的心的图片放在这个数组备用。</p>
<p>这里对外暴露一个 <code>SetActive</code> 用来控制让心变满或变空的方法。</p>
<p>默认情况下，心是空的。</p>
<p><img src="https://files.catbox.moe/wzlt1g.jpg" alt="空的心"></p>
<p>进入游戏测试：</p>
<p><img src="https://files.catbox.moe/wesj3x.jpg" alt="测试填充心"></p>
<p>可以发现心已经被填满了，这是因为通过脚本调用 <code>SetActive</code> 方法修改了心的图片。</p>
<p>心形血量这样就完成了，拖到 <code>Resources/Prefabs/MiniGame</code> 下作为预制体备用。</p>
<h4 id="血量控制"><a href="#血量控制" class="headerlink" title="血量控制"></a>血量控制</h4><p>心形血量的控制交给 Layout。</p>
<p>新建 <code>MiniGame_HeartLayout</code> 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MiniGame_HeartLayout : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;MiniGame_Heart&gt; hearts &#x3D; new List&lt;MiniGame_Heart&gt;();</span><br><span class="line"></span><br><span class="line">    [HideInInspector]</span><br><span class="line">    public MiniGame_Player player;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        player &#x3D; GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;MiniGame_Player&gt;();</span><br><span class="line"></span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void UpdateLast(bool result)</span><br><span class="line">    &#123;</span><br><span class="line">        GetCurrentHeart().SetActive(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MiniGame_Heart GetCurrentHeart()</span><br><span class="line">    &#123;</span><br><span class="line">        int index &#x3D; player.currentHP - 1;</span><br><span class="line"></span><br><span class="line">        return hearts[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; player.maxHP; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            CreateHeart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void CreateHeart()</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject prefab &#x3D; Resources.Load(&quot;Prefabs&#x2F;MiniGame&#x2F;Heart&quot;) as GameObject;</span><br><span class="line">        GameObject heartObj &#x3D; Instantiate(prefab, transform);</span><br><span class="line"></span><br><span class="line">        MiniGame_Heart heart &#x3D; heartObj.GetComponent&lt;MiniGame_Heart&gt;();</span><br><span class="line"></span><br><span class="line">        hearts.Add(heart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要修改之前的设定，角色的血量原来设定成 float 类型，需要改成 int。</p>
<p>脚本初始化时自动获取场景的 Player 对象，然后根据玩家的最大血量自动初始化对应的心形血量。</p>
<p>提供了一个可以控制血量变空和填满的方法：<code>UpdateLast</code>。</p>
<p>进入游戏测试：</p>
<p><img src="https://files.catbox.moe/kgpyud.jpg" alt="测试血量容器"></p>
<p>测试 OK，然后在场景控制器新增一个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public MiniGame_HeartLayout heartLayout;</span><br></pre></td></tr></table></figure>

<p>将容器赋值给场景控制器，这样在场景控制器里就可以对心形容器进行控制了。</p>
<h2 id="道具系统"><a href="#道具系统" class="headerlink" title="道具系统"></a>道具系统</h2><p>游戏中存在 4 种道具。</p>
<ul>
<li>樱桃：在场景中出现，吃到可以加分</li>
<li>金币：打败怪物出现，吃到可以加分</li>
<li>爱心：在场景中出现，吃到可以恢复1点HP</li>
<li>布偶：打败BOSS爆出，吃到可以加分（在正式篇触发隐藏事件）</li>
</ul>
<p>总体来说可以分成两类：①加分 ②加血</p>
<p>搞清楚之后，就可以开始制作道具了。</p>
<h3 id="道具基类"><a href="#道具基类" class="headerlink" title="道具基类"></a>道具基类</h3><p>道具存在许多共通点，可以抽取出道具的基类。</p>
<p>创建脚本 <code>MiniGame_Item</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public abstract class MiniGame_Item : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public int score;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            TouchEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void TakeScore()</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject root &#x3D; GameObject.FindGameObjectWithTag(&quot;Controller&quot;);</span><br><span class="line">        MiniGame_Controller ctrl &#x3D; root.GetComponent&lt;MiniGame_Controller&gt;();</span><br><span class="line"></span><br><span class="line">        ctrl.AddScore(score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void TouchEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（其实这个脚本是修改之后的结果，原来是监听刚体碰撞，后来改成了监听触发器，下文解释为什么要这么改）</p>
<p>道具基类包含了一个 <code>score</code> 参数，用于计算角色吃到道具的得分。</p>
<p><code>TakeScore</code> 方法是吃到加分道具时更新场景的分数显示的通用方法。</p>
<p>道具只要监听与主角的碰撞事件即可，然后声明一个抽象方法，获得道具的效果在子类实现。</p>
<h3 id="加分道具"><a href="#加分道具" class="headerlink" title="加分道具"></a>加分道具</h3><p>加分道具的逻辑很简单，只要玩家吃到道具，更新场景右上角显示的分数即可。</p>
<p>最后销毁道具就完了。</p>
<h4 id="动态效果"><a href="#动态效果" class="headerlink" title="动态效果"></a>动态效果</h4><p>为了节约时间，直接使用第三方提供的插件包 <code>Itween</code> 来制作动态效果。</p>
<p>这是一个可以控制运动、数值变化的插件。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://assetstore.unity.com/packages/tools/animation/itween-84?locale=zh-CN">iTween</a></p>
<p>直接从 unity 商店添加到工程即可。</p>
<p><img src="https://files.catbox.moe/nmpnl6.jpg" alt="添加itween"></p>
<p>获得资源后，在 Unity 的 Window 菜单中选择 <code>Package Manage</code>（包管理）</p>
<p>在打开的窗口中选择 <code>My Assets</code> 即可看到刚才从商店中获取的 <code>Itween</code> 插件包了。</p>
<p><img src="https://files.catbox.moe/w7q4ed.jpg" alt="获取我的插件"></p>
<p>然后选择导入到工程即可。</p>
<p><img src="https://files.catbox.moe/2un1w2.jpg" alt="导入itween"></p>
<p>导入的插件放在 <code>Assets/Plugins</code> 目录下，插件会自动加载，因此这样就完成了。</p>
<h4 id="樱桃"><a href="#樱桃" class="headerlink" title="樱桃"></a>樱桃</h4><p>樱桃是直接出现在场景的道具，它漂浮在空中，有规律的上下浮动。</p>
<p>在场景中添加樱桃的游戏对象：</p>
<p><img src="https://files.catbox.moe/d4y2oo.jpg" alt="樱桃道具"></p>
<p>创建樱桃脚本 <code>MiniGame_CherryItem</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MiniGame_CherryItem : MiniGame_Item</span><br><span class="line">&#123;</span><br><span class="line">    public float moveSpeed &#x3D; 5f;</span><br><span class="line">    public float height &#x3D; 10f;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        iTween.ValueTo(gameObject, new Hashtable</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;from&quot;, height &#125;,</span><br><span class="line">            &#123; &quot;to&quot;, -height &#125;,</span><br><span class="line">            &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">            &#123; &quot;loopType&quot;, iTween.LoopType.pingPong &#125;,</span><br><span class="line">            &#123; &quot;onUpdate&quot;, &quot;MoveAction&quot; &#125;,</span><br><span class="line">            &#123; &quot;onUpdateTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;time&quot;, 0.5f &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void TouchEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        TakeScore();</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void MoveAction(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos &#x3D; transform.position;</span><br><span class="line"></span><br><span class="line">        pos.y +&#x3D; value * moveSpeed;</span><br><span class="line">        transform.position &#x3D; pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iTween.ValueTo</code> 方法的作用是动态的将一个初始值 a，调整到 b。</p>
<p><code>loopType</code> 循环类型为：<code>iTween.LoopType.pingPong</code>，即像打乒乓球一样有来有回。</p>
<p>比如先从 0 到 1，这样就算值的变化结束了，然后又从 1 到 0，始终如此循环。</p>
<p><code>easeType</code> 参数指定了变化的曲线，<code>iTween.EaseType.linear</code> 即线性变化，可以理解为均匀的变化。</p>
<p>参数的 <code>height</code> 指定了樱桃漂浮的高度，通过 <code>ValueTo</code> 方法在这个高度范围内变化。</p>
<p>每次值改变的时候就会调用 <code>MoveAction</code> 方法修改樱桃的 y 坐标。</p>
<p>这样樱桃的漂浮轨迹就完成了。</p>
<p>演示效果：</p>
<p><img src="https://files.catbox.moe/vr39nk.gif" alt="漂浮的樱桃"></p>
<p>吃到樱桃右上角的分数也更新了。</p>
<p>发现角色在吃到道具的时候，发生了刚体碰撞，导致角色被道具反弹了一下，影响手感。</p>
<p>此处是因为我把道具也设置成刚体了，只要将道具设置为触发器，并且移除刚体组件即可。</p>
<p>然后修改 Item 的碰撞回调为触发器回调即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        TouchEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新测试：</p>
<p><img src="https://files.catbox.moe/akm99i.gif" alt="移除道具的刚体"></p>
<p>刚体碰撞的问题也解决了。</p>
<h4 id="金币"><a href="#金币" class="headerlink" title="金币"></a>金币</h4><p>金币有自己的动画效果，先给金币加上动画。</p>
<p><img src="https://files.catbox.moe/n9fz55.gif" alt="金币动画"></p>
<p>金币在生成的时候，会有一个“爆出”的效果，即向上飞出然后落到地上消失。</p>
<p>原来的道具基类没有接触地板的判断，因此需要进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public abstract class MiniGame_Item : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public int score;</span><br><span class="line">    protected Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        rb &#x3D; GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        string tag &#x3D; collision.gameObject.tag;</span><br><span class="line"></span><br><span class="line">        switch (tag)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;Player&quot;:</span><br><span class="line">                TouchPlayerEvent();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;Ground&quot;:</span><br><span class="line">                TouchGroundEvent();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void TakeScore()</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject root &#x3D; GameObject.FindGameObjectWithTag(&quot;Controller&quot;);</span><br><span class="line">        MiniGame_Controller ctrl &#x3D; root.GetComponent&lt;MiniGame_Controller&gt;();</span><br><span class="line"></span><br><span class="line">        ctrl.AddScore(score);</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void TouchGroundEvent();</span><br><span class="line">    protected abstract void TouchPlayerEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增抽象方法 <code>TouchGroundEvent</code>，用于执行道具与地板接触的处理。</p>
<p>然后创建金币道具类 <code>MiniGame_GoldItem</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MiniGame_GoldItem : MiniGame_Item</span><br><span class="line">&#123;</span><br><span class="line">    public float ySpeed &#x3D; 300f;</span><br><span class="line">    public float time &#x3D; 1.5f;</span><br><span class="line"></span><br><span class="line">    private float currentSpeed;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        iTween.ValueTo(gameObject, new Hashtable</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;from&quot;, ySpeed &#125;,</span><br><span class="line">            &#123; &quot;to&quot;, -ySpeed &#125;,</span><br><span class="line">            &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">            &#123; &quot;onUpdate&quot;, &quot;MoveAction&quot; &#125;,</span><br><span class="line">            &#123; &quot;onUpdateTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;time&quot;, time &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void TouchGroundEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void TouchPlayerEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        TakeScore();</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void MoveAction(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        currentSpeed &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos &#x3D; transform.position;</span><br><span class="line"></span><br><span class="line">        pos.y +&#x3D; currentSpeed * Time.deltaTime;</span><br><span class="line">        transform.position &#x3D; pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样利用了 <code>ValueTo</code> 方法的值变化。</p>
<p>金币的上抛速度先是从最大值逐渐减到负数，这样就会反向运动了。</p>
<p>最后掉落到地上把金币销毁就可以了。</p>
<p>演示效果：</p>
<p><img src="https://files.catbox.moe/y5xb5x.gif" alt="爆出金币"></p>
<p>直接消失的观感似乎不怎么好，以后如果有时间的话再优化。</p>
<h4 id="分值显示"><a href="#分值显示" class="headerlink" title="分值显示"></a>分值显示</h4><p>吃到加分道具的时候，会在原地留下一个分数显示的文本。</p>
<p>然后逐渐向上飞行然后淡出。</p>
<p><img src="https://files.catbox.moe/hj2nno.jpg" alt="分数显示效果"></p>
<p>做法十分简单，创建一个 Text 对象。</p>
<p>再创建用来控制文本逻辑的脚本 <code>MiniGame_ScoreText</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class MiniGame_ScoreText : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public int score;</span><br><span class="line">    public Text text;</span><br><span class="line">    public float time &#x3D; 1f;</span><br><span class="line">    public float speed &#x3D; 10f;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        text &#x3D; GetComponent&lt;Text&gt;();</span><br><span class="line">        text.text &#x3D; &quot;+&quot; + score.ToString();</span><br><span class="line"></span><br><span class="line">        iTween.ValueTo(gameObject, new Hashtable</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;from&quot;, 1f &#125;,</span><br><span class="line">            &#123; &quot;to&quot;, 0f &#125;,</span><br><span class="line">            &#123; &quot;easeType&quot;, iTween.EaseType.linear &#125;,</span><br><span class="line">            &#123; &quot;onUpdate&quot;, &quot;UpdateColor&quot; &#125;,</span><br><span class="line">            &#123; &quot;onUpdateTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;onComplete&quot;, &quot;Hiden&quot; &#125;,</span><br><span class="line">            &#123; &quot;onCompleteTarget&quot;, gameObject &#125;,</span><br><span class="line">            &#123; &quot;time&quot;, time &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void UpdateColor(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        text.color &#x3D; new Color(1, 1, 1, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Hiden()</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos &#x3D; transform.position;</span><br><span class="line">        pos.y +&#x3D; speed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        transform.position &#x3D; pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示效果:</p>
<p><img src="https://files.catbox.moe/g0rab2.gif" alt="加分文本"></p>
<h3 id="加血道具"><a href="#加血道具" class="headerlink" title="加血道具"></a>加血道具</h3><p>加血道具直接使用心形图标即可，这样玩家看了就知道这是回血的。</p>
<p>因为要调用到回血的方法，所以修改 Item 基类，把碰撞体也作为参数传给子类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void TouchGroundEvent(Collider2D collision);</span><br><span class="line">protected abstract void TouchPlayerEvent(Collider2D collision);</span><br></pre></td></tr></table></figure>

<p>然后给 Player 方法添加回血方法，修改 <code>MiniGame_Character</code> 基类，自动获取场景控制器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected MiniGame_Controller controller;</span><br><span class="line"></span><br><span class="line">controller &#x3D; GameObject.FindGameObjectWithTag(&quot;Controller&quot;).GetComponent&lt;MiniGame_Controller&gt;();</span><br></pre></td></tr></table></figure>

<p>如此一来在子类中就可以直接获得控制器了。</p>
<p>接着修改 <code>MiniGame_Player</code>，添加回血方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void RecoverHP()</span><br><span class="line">&#123;</span><br><span class="line">    if (currentHP &gt;&#x3D; maxHP)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentHP +&#x3D; 1;</span><br><span class="line">    controller.heartLayout.UpdateLast(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用这个方法可以恢复 1 点 HP。</p>
<p>这里需要先让当前 HP 增加，然后才调用 <code>UpdateLast</code> 方法（因为此方法是让最后一格血量充满）。</p>
<p>然后是主角受伤的时候，应该扣掉一格血。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public override void TakeDamage(int damage)</span><br><span class="line">&#123;</span><br><span class="line">    controller.heartLayout.UpdateLast(false);</span><br><span class="line"></span><br><span class="line">    currentHP -&#x3D; damage;</span><br><span class="line">    animator.SetBool(&quot;hurt&quot;, true);</span><br><span class="line"></span><br><span class="line">    Wait(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(&quot;hurt&quot;, false);</span><br><span class="line"></span><br><span class="line">        if (currentHP &lt;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            DeadCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, pretectedTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>受伤时应该后先更新血量的标志，然后再扣除当前 HP。</p>
<p>接着是吃到补血道具时，要调用 Player 的回复 HP 的方法。</p>
<p>新建 <code>MiniGame_HeartItem</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MiniGame_HeartItem : MiniGame_Item</span><br><span class="line">&#123;</span><br><span class="line">    protected override void TouchGroundEvent(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void TouchPlayerEvent(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        MiniGame_Player player &#x3D; collision.GetComponent&lt;MiniGame_Player&gt;();</span><br><span class="line"></span><br><span class="line">        player.RecoverHP();</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>心形道具与角色碰撞时，获得 Player 脚本，然后调用回血方法。</p>
<p>最后销毁自身，让道具消失。</p>
<p>演示效果：</p>
<p><img src="https://files.catbox.moe/yw4vpt.gif" alt="受伤与回血"></p>
<h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>早上 9 点兴奋的起床，开始撸代码。</p>
<p>结果到现在第二天的 00:36 还没弄完……</p>
<p>高估了自己的制作速度。</p>
<p>看来还需要一篇才能真正的完结了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">火烧兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huotuyouxi.com/2021/05/07/monster-game-7/">http://huotuyouxi.com/2021/05/07/monster-game-7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huotuyouxi.com">火兔游戏工作室</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">开发技术</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/08/monster-game-8/"><i class="fa fa-chevron-left">  </i><span>名为怪物的游戏——《星之魔女》FC小游戏移植（八）</span></a></div><div class="next-post pull-right"><a href="/2021/05/06/monster-game-6/"><span>名为怪物的游戏——《星之魔女》FC小游戏移植（六）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/05/02/61DLs9VHetxbq2n.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By 火烧兔子</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>